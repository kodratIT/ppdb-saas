# Epic 2.7 Testing Infrastructure Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Ship reliable integration + E2E test infrastructure (DB, RLS, fixtures, CI triggers) so Epic 3 can start on a production‑ready base.

**Architecture:** Use a dedicated test database (Neon or local Postgres) driven by `DATABASE_URL`, run Drizzle migrations before integration/E2E tests, and seed fixtures for auth/tenants. E2E runs on PR approval (separate workflow) while unit tests remain on every PR/push.

**Tech Stack:** SvelteKit, Vitest, Playwright, Drizzle ORM, PostgreSQL (Neon), GitHub Actions.

---

### Task 1: Add test env configuration + DB bootstrap

**Files:**
- Create: `ppdb/.env.test.example`
- Modify: `ppdb/src/setupTests.ts`
- Modify: `ppdb/package.json`

**Step 1: Write the failing test**

```ts
// tests/integration/db-bootstrap.test.ts
import { describe, it, expect } from 'vitest';
import { db } from '$lib/server/db';
import { sql } from 'drizzle-orm';

describe('test db bootstrap', () => {
  it('connects to test database', async () => {
    const result = await db.execute(sql`select 1 as ok`);
    expect(result.rows[0].ok).toBe(1);
  });
});
```

**Step 2: Run test to verify it fails**

Run: `DATABASE_URL="" yarn vitest tests/integration/db-bootstrap.test.ts -v`
Expected: FAIL with `DATABASE_URL is not set`

**Step 3: Write minimal implementation**

- Create `ppdb/.env.test.example`:
```
DATABASE_URL=postgresql://user:pass@host:5432/ppdb_test
WAHA_BASE_URL=http://localhost:3001
WAHA_SESSION=test-session
FIREBASE_PROJECT_ID=your-project
FIREBASE_CLIENT_EMAIL=your-email
FIREBASE_PRIVATE_KEY="-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----\n"
```

- Update `ppdb/src/setupTests.ts` to set safe defaults for test runs:
```ts
import '@testing-library/jest-dom/vitest';

process.env.DATABASE_URL ??= 'postgresql://ppdb:ppdb@localhost:5433/ppdb_test';
```

- Update `ppdb/package.json` scripts to expose test env entrypoint:
```json
"test:unit": "vitest",
"test:integration": "vitest tests/integration --run",
```

**Step 4: Run test to verify it passes**

Run: `DATABASE_URL="postgresql://ppdb:ppdb@localhost:5433/ppdb_test" yarn vitest tests/integration/db-bootstrap.test.ts -v`
Expected: PASS

**Step 5: Commit**

```bash
git add ppdb/.env.test.example ppdb/src/setupTests.ts ppdb/package.json tests/integration/db-bootstrap.test.ts
git commit -m "test: add test db bootstrap and env defaults"
```

---

### Task 2: Setup Neon test DB in CI + run migrations

**Files:**
- Modify: `ppdb/.github/workflows/ci.yml`

**Step 1: Write the failing test**

Use Task 1’s bootstrap test to fail CI when DB isn’t available.

**Step 2: Run test to verify it fails**

Run locally without `DATABASE_URL`: `yarn vitest tests/integration/db-bootstrap.test.ts -v`
Expected: FAIL

**Step 3: Write minimal implementation**

- Update `ppdb/.github/workflows/ci.yml`:
```yml
      - run: npm ci
      - run: npm run check
      - run: npm run lint
      - run: npm run test
        env:
          DATABASE_URL: ${{ secrets.NEON_TEST_DATABASE_URL }}
      - run: npx drizzle-kit migrate
        env:
          DATABASE_URL: ${{ secrets.NEON_TEST_DATABASE_URL }}
      - run: npm run test:integration
        env:
          DATABASE_URL: ${{ secrets.NEON_TEST_DATABASE_URL }}
      - run: npm run build
```

**Step 4: Run test to verify it passes**

Run locally with valid test DB: `DATABASE_URL=... yarn test:integration`
Expected: PASS

**Step 5: Commit**

```bash
git add ppdb/.github/workflows/ci.yml
git commit -m "ci: add neon test db + migrations for integration tests"
```

---

### Task 3: Implement RLS integration tests

**Files:**
- Modify: `ppdb/tests/unit/rls.test.ts`
- Create: `ppdb/tests/integration/rls.integration.test.ts`

**Step 1: Write the failing test**

```ts
import { describe, it, expect } from 'vitest';
import { db } from '$lib/server/db';
import { sql } from 'drizzle-orm';
import { admissionPaths } from '$lib/server/db/schema';

const TENANT_A = '00000000-0000-0000-0000-000000000001';
const TENANT_B = '00000000-0000-0000-0000-000000000002';

describe('RLS tenant isolation', () => {
  it('only returns rows for current tenant', async () => {
    await db.execute(sql`select set_config('app.current_tenant_id', ${TENANT_A}, true)`);
    const rowsA = await db.select().from(admissionPaths);
    await db.execute(sql`select set_config('app.current_tenant_id', ${TENANT_B}, true)`);
    const rowsB = await db.select().from(admissionPaths);
    expect(rowsA).not.toEqual(rowsB);
  });
});
```

**Step 2: Run test to verify it fails**

Run: `DATABASE_URL=... yarn vitest tests/integration/rls.integration.test.ts -v`
Expected: FAIL until tenant fixtures exist.

**Step 3: Write minimal implementation**

- Seed tenant fixtures in test setup (see Task 4) so both tenants exist.
- Ensure `set_config` is used before each query.

**Step 4: Run test to verify it passes**

Run: `DATABASE_URL=... yarn vitest tests/integration/rls.integration.test.ts -v`
Expected: PASS

**Step 5: Commit**

```bash
git add ppdb/tests/integration/rls.integration.test.ts ppdb/tests/unit/rls.test.ts
git commit -m "test: add RLS integration coverage"
```

---

### Task 4: Add auth/tenant fixtures for tests

**Files:**
- Create: `ppdb/tests/fixtures/tenants.ts`
- Create: `ppdb/tests/fixtures/users.ts`
- Modify: `ppdb/tests/integration/rls.integration.test.ts`

**Step 1: Write the failing test**

```ts
import { seedTenants } from '../fixtures/tenants';
import { seedUsers } from '../fixtures/users';

await seedTenants();
await seedUsers();
```

**Step 2: Run test to verify it fails**

Run: `DATABASE_URL=... yarn vitest tests/integration/rls.integration.test.ts -v`
Expected: FAIL with missing fixture helper.

**Step 3: Write minimal implementation**

`ppdb/tests/fixtures/tenants.ts`
```ts
import { db } from '$lib/server/db';
import { tenants } from '$lib/server/db/schema';

export async function seedTenants() {
  await db.insert(tenants).values([
    { id: '00000000-0000-0000-0000-000000000001', name: 'Tenant A' },
    { id: '00000000-0000-0000-0000-000000000002', name: 'Tenant B' }
  ]).onConflictDoNothing();
}
```

`ppdb/tests/fixtures/users.ts`
```ts
import { db } from '$lib/server/db';
import { users } from '$lib/server/db/schema';

export async function seedUsers() {
  await db.insert(users).values([
    {
      id: '10000000-0000-0000-0000-000000000001',
      tenantId: '00000000-0000-0000-0000-000000000001',
      email: 'admin-a@ppdb.test',
      role: 'school_admin'
    },
    {
      id: '10000000-0000-0000-0000-000000000002',
      tenantId: '00000000-0000-0000-0000-000000000002',
      email: 'admin-b@ppdb.test',
      role: 'school_admin'
    }
  ]).onConflictDoNothing();
}
```

**Step 4: Run test to verify it passes**

Run: `DATABASE_URL=... yarn vitest tests/integration/rls.integration.test.ts -v`
Expected: PASS

**Step 5: Commit**

```bash
git add ppdb/tests/fixtures/tenants.ts ppdb/tests/fixtures/users.ts ppdb/tests/integration/rls.integration.test.ts
git commit -m "test: add tenant/user fixtures for integration tests"
```

---

### Task 5: Run E2E in CI on PR approval

**Files:**
- Create: `ppdb/.github/workflows/e2e.yml`
- Modify: `ppdb/playwright.config.ts`

**Step 1: Write the failing test**

Ensure current CI has no E2E workflow (missing file). This is the “failing” state.

**Step 2: Verify it’s missing**

Run: `ls ppdb/.github/workflows` and confirm `e2e.yml` absent.

**Step 3: Write minimal implementation**

Create `ppdb/.github/workflows/e2e.yml`:
```yml
name: E2E
on:
  pull_request_review:
    types: [submitted]

jobs:
  e2e:
    if: github.event.review.state == 'approved'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'yarn'
      - run: yarn install --immutable
      - run: yarn build
        env:
          DATABASE_URL: ${{ secrets.NEON_TEST_DATABASE_URL }}
      - run: yarn test:e2e
        env:
          DATABASE_URL: ${{ secrets.NEON_TEST_DATABASE_URL }}
```

Update `ppdb/playwright.config.ts` webServer command to yarn:
```ts
webServer: {
  command: 'yarn build && yarn preview --host 127.0.0.1 --port 5173',
  url: 'http://127.0.0.1:5173',
  reuseExistingServer: !process.env.CI,
  timeout: 120000
}
```

**Step 4: Run test to verify it passes**

Run: `DATABASE_URL=... yarn test:e2e`
Expected: Playwright runs and exits 0

**Step 5: Commit**

```bash
git add ppdb/.github/workflows/e2e.yml ppdb/playwright.config.ts
git commit -m "ci: run e2e on PR approval"
```

---

## Notes / Open Questions
- Confirm secret name: `NEON_TEST_DATABASE_URL` (or preferred).
- Decide whether integration tests run on merge to main or on every PR.
- Confirm minimal E2E scenarios (5–10) for Epic 2.7 acceptance.

---

Plan complete and saved to `docs/plans/2026-01-10-epic-2.7-testing-infrastructure.md`. Two execution options:

1. Subagent-Driven (this session) — I dispatch fresh subagent per task, review between tasks, fast iteration
2. Parallel Session (separate) — Open new session with executing-plans, batch execution with checkpoints

Which approach?
